# New W.I.P | Voxel Terrain Game

![Main menu](./images/mainmenu.jpg "Main Menu")

In June I began working on a voxel terrain game created using the Unity 3D engine. The terrain is generated by mixing 3D and 2D Perlin noise, then extracting an isosurface using the Marching Cubes algorithm, which I implemented myself. I did some research, and planned out the how to implement the algorithm in Unity C# on my whiteboard, and after fixing a few typos, it worked on the first run. I was only able to generate a few cubic meters at a time, without drastically limiting the framerate of the game. I was inspired by [Sebastian Lague's Marching Cube video](https://www.youtube.com/watch?v=M3iI2l0ltbE) on YouTube to offload the computations to the GPU. This allowed me to create something which began to seem playable.
  
In the end, even the GPU was not able to handle the terrain to the extent I wanted. I decided to pursue multithreading. Unity has no built-in support for multithreading however, and most importantly, only allows Meshes to be created on the main thread. However, the mesh data (vertices, triangles, etc...) can be prepared on a worker thread. I used the C# Task system to accomplish this, and a coroutine to wait for the Task to return the Mesh data, and then create the Mesh on the main thread.
    
Still, I ran into some major frame rate problems in certain situations. My solution, which I have yet to have the time to implement, is to have the Tasks post the prepared Mesh data to a queue, managed by the ChunkManager, instead of having the Chunk's own coroutine observe it. The ChunkManager will then dequeue the Mesh data and ensure that only a reasonable number of meshes are prepared per frame. If the nearby chunks are created when the player first loads into the map (or teleports), then the latency of the mesh generation shouldn't be noticeable.

## Update - August 3rd, 2019

Now that the basic terrain generation is stable, I've been playing around with 'spicying' it up a bit. I was able to quickly add basic procedurally generated trees to the game, but most of all, I have begun to experiment with water. I initally attempted to introduce it directly to the game, but found it was too hard to debug, so I created a seperate scene with only one basic terrain chunk, and one water chunk. I also cleaned up the code to make it easier to work with. Here is the latest demo:

![Water demo](./Videos/waterTest.gif "Water demo")

As you can see, the water will spread horizontally and downwards until it hits terrain. The next step is to implement a concept of finite water, so the depth will decrease the more it spreads out.

## Update - July 31st, 2019

All known framerate issues due to terrain have been fixed, at least for reasonable view distances (< 64 on my computer). There were many many problems that led to the framerate issues. In the process of debugging it, I have really understood the importance of writing clean, well-documented code from the beginning.

Now I can beginning re-implementing terrain materials, and creating a fun, stable game using the terrain system I have built.

Check back soon for more updates!

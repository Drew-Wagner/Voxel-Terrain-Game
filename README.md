# New W.I.P | Voxel Terrain Game

![Main menu](./images/mainmenu.jpg "Main Menu")

In June I began working on a voxel terrain game created using the Unity 3D engine. The terrain is generated by mixing 3D and 2D Perlin noise, then extracting an isosurface using the Marching Cubes algorithm, which I implemented myself. I did some research, and planned out the how to implement the algorithm in Unity C# on my whiteboard, and after fixing a few typos, it worked on the first run. I was only able to generate a few cubic meters at a time, without drastically limiting the framerate of the game. I was inspired by [Sebastian Lague's Marching Cube video](https://www.youtube.com/watch?v=M3iI2l0ltbE) on YouTube to offload the computations to the GPU. This allowed me to create something which began to seem playable.
  
In the end, even the GPU was not able to handle the terrain to the extent I wanted. I decided to pursue multithreading. Unity has no built-in support for multithreading however, and most importantly, only allows Meshes to be created on the main thread. However, the mesh data (vertices, triangles, etc...) can be prepared on a worker thread. I used the C# Task system to accomplish this, and a coroutine to wait for the Task to return the Mesh data, and then create the Mesh on the main thread.
    
Still, I ran into some major frame rate problems in certain situations. My solution, which I have yet to have the time to implement, is to have the Tasks post the prepared Mesh data to a queue, managed by the ChunkManager, instead of having the Chunk's own coroutine observe it. The ChunkManager will then dequeue the Mesh data and ensure that only a reasonable number of meshes are prepared per frame. If the nearby chunks are created when the player first loads into the map (or teleports), then the latency of the mesh generation shouldn't be noticeable.

More GIFs, ideas, plans, and info coming soon... Don't forget to check back!
